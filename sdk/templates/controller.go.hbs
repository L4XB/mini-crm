// Code generated by Mini CRM SDK - DO NOT EDIT.
// Generated at: {{timestamp}}

package controllers

import (
	"net/http"
	"strconv"

	"github.com/deinname/mini-crm-backend/config"
	"github.com/deinname/mini-crm-backend/models"
	"github.com/deinname/mini-crm-backend/utils"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

// {{model.name}}Controller handles the {{model.name}} entity API endpoints
type {{model.name}}Controller struct {
	DB *gorm.DB
}

// New{{model.name}}Controller creates a new controller for {{model.name}}
func New{{model.name}}Controller() *{{model.name}}Controller {
	return &{{model.name}}Controller{
		DB: config.DB,
	}
}

// Create{{model.name}} creates a new {{model.name}}
// @Summary Create a new {{model.name}}
// @Description Create a new {{model.name}} with the input payload
// @Tags {{model.tableName}}
// @Accept json
// @Produce json
// @Param data body models.{{model.name}} true "{{model.name}} data"
// @Success 201 {object} utils.Response{data=models.{{model.name}}}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 500 {object} utils.Response
// @Router /api/v1/{{model.tableName}} [post]
// @Security BearerAuth
func (c *{{model.name}}Controller) Create{{model.name}}(ctx *gin.Context) {
	var input models.{{model.name}}
	if err := ctx.ShouldBindJSON(&input); err != nil {
		utils.SendError(ctx, http.StatusBadRequest, err.Error())
		return
	}

	// Get user ID from context
	userID, exists := ctx.Get("user_id")
	if !exists {
		utils.SendError(ctx, http.StatusUnauthorized, "unauthorized")
		return
	}

	// Set creator user ID if applicable
	// Uncomment if your model has a UserID field
	// input.UserID = userID.(uint)

	// Create record
	if err := c.DB.Create(&input).Error; err != nil {
		utils.SendError(ctx, http.StatusInternalServerError, err.Error())
		return
	}

	utils.SendSuccess(ctx, http.StatusCreated, "{{model.name}} created successfully", input)
}

// Get{{model.name}}s gets all {{model.name}}s
// @Summary Get all {{model.name}}s
// @Description Get all {{model.name}}s, optionally filtered by query parameters
// @Tags {{model.tableName}}
// @Accept json
// @Produce json
// @Param page query int false "Page number"
// @Param limit query int false "Items per page"
// @Success 200 {object} utils.Response{data=[]models.{{model.name}}}
// @Failure 401 {object} utils.Response
// @Failure 500 {object} utils.Response
// @Router /api/v1/{{model.tableName}} [get]
// @Security BearerAuth
func (c *{{model.name}}Controller) Get{{model.name}}s(ctx *gin.Context) {
	var {{model.tableName}} []models.{{model.name}}

	// Get user ID from context
	userID, exists := ctx.Get("user_id")
	if !exists {
		utils.SendError(ctx, http.StatusUnauthorized, "unauthorized")
		return
	}

	// Get role from context
	role, _ := ctx.Get("user_role")

	// Parse pagination parameters
	page, _ := strconv.Atoi(ctx.DefaultQuery("page", "1"))
	limit, _ := strconv.Atoi(ctx.DefaultQuery("limit", "10"))
	offset := (page - 1) * limit

	// Prepare query
	query := c.DB.Model(&models.{{model.name}}{})

	// If not admin, filter by user ID
	if role != "admin" {
		// Uncomment if your model has a UserID field
		// query = query.Where("user_id = ?", userID)
	}

	// Count total items for pagination
	var total int64
	if err := query.Count(&total).Error; err != nil {
		utils.SendError(ctx, http.StatusInternalServerError, err.Error())
		return
	}

	// Get paginated results
	if err := query.Limit(limit).Offset(offset).Find(&{{model.tableName}}).Error; err != nil {
		utils.SendError(ctx, http.StatusInternalServerError, err.Error())
		return
	}

	// Send paginated response
	utils.SendPaginatedSuccess(ctx, "{{model.name}}s retrieved successfully", {{model.tableName}}, page, limit, int(total))
}

// Get{{model.name}} gets a {{model.name}} by ID
// @Summary Get a {{model.name}} by ID
// @Description Get a {{model.name}} by ID
// @Tags {{model.tableName}}
// @Accept json
// @Produce json
// @Param id path int true "{{model.name}} ID"
// @Success 200 {object} utils.Response{data=models.{{model.name}}}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Failure 500 {object} utils.Response
// @Router /api/v1/{{model.tableName}}/{id} [get]
// @Security BearerAuth
func (c *{{model.name}}Controller) Get{{model.name}}(ctx *gin.Context) {
	id, err := strconv.Atoi(ctx.Param("id"))
	if err != nil {
		utils.SendError(ctx, http.StatusBadRequest, "invalid ID format")
		return
	}

	var {{camelCase model.name}} models.{{model.name}}
	if err := c.DB.First(&{{camelCase model.name}}, id).Error; err != nil {
		utils.SendError(ctx, http.StatusNotFound, "{{model.name}} not found")
		return
	}

	// Get user ID and role from context
	userID, exists := ctx.Get("user_id")
	if !exists {
		utils.SendError(ctx, http.StatusUnauthorized, "unauthorized")
		return
	}
	
	role, _ := ctx.Get("user_role")

	// Check ownership if not admin
	// Uncomment if your model has a UserID field
	// if role != "admin" && {{camelCase model.name}}.UserID != userID.(uint) {
	//     utils.SendError(ctx, http.StatusForbidden, "not authorized to access this {{model.name}}")
	//     return
	// }

	utils.SendSuccess(ctx, http.StatusOK, "{{model.name}} retrieved successfully", {{camelCase model.name}})
}

// Update{{model.name}} updates a {{model.name}} by ID
// @Summary Update a {{model.name}} by ID
// @Description Update a {{model.name}} by ID with the input payload
// @Tags {{model.tableName}}
// @Accept json
// @Produce json
// @Param id path int true "{{model.name}} ID"
// @Param data body models.{{model.name}} true "{{model.name}} data"
// @Success 200 {object} utils.Response{data=models.{{model.name}}}
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Failure 500 {object} utils.Response
// @Router /api/v1/{{model.tableName}}/{id} [put]
// @Security BearerAuth
func (c *{{model.name}}Controller) Update{{model.name}}(ctx *gin.Context) {
	id, err := strconv.Atoi(ctx.Param("id"))
	if err != nil {
		utils.SendError(ctx, http.StatusBadRequest, "invalid ID format")
		return
	}

	// Check if {{model.name}} exists
	var {{camelCase model.name}} models.{{model.name}}
	if err := c.DB.First(&{{camelCase model.name}}, id).Error; err != nil {
		utils.SendError(ctx, http.StatusNotFound, "{{model.name}} not found")
		return
	}

	// Get user ID and role from context
	userID, exists := ctx.Get("user_id")
	if !exists {
		utils.SendError(ctx, http.StatusUnauthorized, "unauthorized")
		return
	}
	
	role, _ := ctx.Get("user_role")

	// Check ownership if not admin
	// Uncomment if your model has a UserID field
	// if role != "admin" && {{camelCase model.name}}.UserID != userID.(uint) {
	//     utils.SendError(ctx, http.StatusForbidden, "not authorized to update this {{model.name}}")
	//     return
	// }

	// Parse input
	var input models.{{model.name}}
	if err := ctx.ShouldBindJSON(&input); err != nil {
		utils.SendError(ctx, http.StatusBadRequest, err.Error())
		return
	}

	// Update record
	if err := c.DB.Model(&{{camelCase model.name}}).Updates(input).Error; err != nil {
		utils.SendError(ctx, http.StatusInternalServerError, err.Error())
		return
	}

	// Get updated record
	c.DB.First(&{{camelCase model.name}}, id)

	utils.SendSuccess(ctx, http.StatusOK, "{{model.name}} updated successfully", {{camelCase model.name}})
}

// Delete{{model.name}} deletes a {{model.name}} by ID
// @Summary Delete a {{model.name}} by ID
// @Description Delete a {{model.name}} by ID
// @Tags {{model.tableName}}
// @Accept json
// @Produce json
// @Param id path int true "{{model.name}} ID"
// @Success 200 {object} utils.Response
// @Failure 400 {object} utils.Response
// @Failure 401 {object} utils.Response
// @Failure 404 {object} utils.Response
// @Failure 500 {object} utils.Response
// @Router /api/v1/{{model.tableName}}/{id} [delete]
// @Security BearerAuth
func (c *{{model.name}}Controller) Delete{{model.name}}(ctx *gin.Context) {
	id, err := strconv.Atoi(ctx.Param("id"))
	if err != nil {
		utils.SendError(ctx, http.StatusBadRequest, "invalid ID format")
		return
	}

	// Check if {{model.name}} exists
	var {{camelCase model.name}} models.{{model.name}}
	if err := c.DB.First(&{{camelCase model.name}}, id).Error; err != nil {
		utils.SendError(ctx, http.StatusNotFound, "{{model.name}} not found")
		return
	}

	// Get user ID and role from context
	userID, exists := ctx.Get("user_id")
	if !exists {
		utils.SendError(ctx, http.StatusUnauthorized, "unauthorized")
		return
	}
	
	role, _ := ctx.Get("user_role")

	// Check ownership if not admin
	// Uncomment if your model has a UserID field
	// if role != "admin" && {{camelCase model.name}}.UserID != userID.(uint) {
	//     utils.SendError(ctx, http.StatusForbidden, "not authorized to delete this {{model.name}}")
	//     return
	// }

	// Delete record
	if err := c.DB.Delete(&{{camelCase model.name}}).Error; err != nil {
		utils.SendError(ctx, http.StatusInternalServerError, err.Error())
		return
	}

	utils.SendSuccess(ctx, http.StatusOK, "{{model.name}} deleted successfully", nil)
}
